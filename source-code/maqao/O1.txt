Target processor is: 11th generation Intel Core processors based on Tiger Lake microarchitecture (x86_64 architecture).

Section 1: Function: saxpy(float, std::vector<float, std::allocator<float> > const&, std::vector<float, std::allocator<float> > const&, std::vector<float, std::allocator<float> >&)
====================================================================================================================================================================================

Code for this function has been compiled to run on any x86-64 processor (SSE2, 2004). It is not optimized for later processors (AVX etc.).
These loops are supposed to be defined in: /home/gjb/Projects/Code-optimization/source-code/maqao/saxpy.cpp

Section 1.1: Source loop ending at line 11
==========================================

Composition and unrolling
-------------------------
It is composed of the loop 0
and is not unrolled or unrolled with no peel/tail loop.

Section 1.1.1: Binary loop #0
=============================

The loop is defined in:
 - /home/gjb/Projects/Code-optimization/source-code/maqao/saxpy.cpp:10-11
 - /usr/include/c++/13/bits/stl_vector.h:990


The related source loop is not unrolled or unrolled with no peel/tail loop.
1% of peak computational performance is used (0.67 out of 64.00 FLOP per cycle (GFLOPS @ 1GHz))

Type of elements and instruction set
------------------------------------
2 SSE or AVX instructions are processing arithmetic or math operations on single precision FP elements in scalar mode (one at a time).


Matching between your loop (in the source code) and the binary loop
-------------------------------------------------------------------
The binary loop is composed of 2 FP arithmetical operations:
 - 1: addition or subtraction
 - 1: multiply
The binary loop is loading 40 bytes (10 single precision FP elements).
The binary loop is storing 4 bytes (1 single precision FP elements).

Arithmetic intensity
--------------------
Arithmetic intensity is 0.05 FP operations per loaded or stored byte.

Unroll opportunity
------------------
Loop is data access bound.
Workaround(s):
Unroll your loop if trip count is significantly higher than target unroll factor and if some data references are common to consecutive iterations. This can be done manually. Or by recompiling with -funroll-loops and/or -floop-unroll-and-jam. Or with the unroll (resp. unroll_and_jam) directive on top of the inner (resp. surrounding) loop. You can enforce an unroll factor: #pragma GCC unroll N

General properties
------------------
nb instructions    : 13
nb uops            : 12
loop length        : 47
used x86 registers : 6
used mmx registers : 0
used xmm registers : 2
used ymm registers : 0
used zmm registers : 0
nb stack references: 0
ADD-SUB / MUL ratio: 1.00


Front-end
---------
ASSUMED MACRO FUSION
FIT IN UOP CACHE
micro-operation queue: 2.40 cycles
front end            : 2.40 cycles


Back-end
--------
       | P0   | P1   | P2   | P3   | P4   | P5   | P6   | P7   | P8   | P9
----------------------------------------------------------------------------
uops   | 1.50 | 1.50 | 3.00 | 3.00 | 0.50 | 1.50 | 1.50 | 0.50 | 0.50 | 0.50
cycles | 1.50 | 1.50 | 3.00 | 3.00 | 0.50 | 1.50 | 1.50 | 0.50 | 0.50 | 0.50

Execution ports to units layout:
 - P0 (256 bits): VPU, BRU, ALU, DIV/SQRT
 - P1 (256 bits): ALU, VPU
 - P2 (512 bits): load
 - P3 (512 bits): load
 - P4 (256 bits): store data
 - P5 (512 bits): ALU, VPU
 - P6: ALU, BRU
 - P7: store address
 - P8: store address
 - P9 (256 bits): store data

Cycles executing div or sqrt instructions: NA
Longest recurrence chain latency (RecMII): 1.00


Cycles summary
--------------
Front-end : 2.40
Dispatch  : 3.00
Data deps.: 1.00
Overall L1: 3.00


Vectorization ratios
--------------------
all     : 25%
load    : 0%
store   : 0%
mul     : 0%
add-sub : 0%
fma     : NA (no fma vectorizable/vectorized instructions)
div/sqrt: NA (no div/sqrt vectorizable/vectorized instructions)
other   : 100%


Vector efficiency ratios
------------------------
all     : 10%
load    : 6%
store   : 6%
mul     : 6%
add-sub : 6%
fma     : NA (no fma vectorizable/vectorized instructions)
div/sqrt: NA (no div/sqrt vectorizable/vectorized instructions)
other   : 25%


Cycles and memory resources usage
---------------------------------
Assuming all data fit into the L1 cache, each iteration of the binary loop takes 3.00 cycles. At this rate:
 - 10% of peak load performance is reached (13.33 out of 128.00 bytes loaded per cycle (GB/s @ 1GHz))
 - 2% of peak store performance is reached (1.33 out of 64.00 bytes stored per cycle (GB/s @ 1GHz))


Front-end bottlenecks
---------------------
Found no such bottlenecks.

ASM code
--------
In the binary file, the address of the loop is: 141f

Instruction                                        | Nb FU | P0   | P1   | P2   | P3   | P4   | P5   | P6   | P7   | P8   | P9   | Latency | Recip. throughput | Vectorization
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MOV (%R8),%RDX                                     | 1     | 0    | 0    | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 2       | 0.50              | N/A
MOVAPS %XMM0,%XMM1                                 | 1     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0       | 0.20              | vect (25.0%)
MULSS (%RCX,%RAX,4),%XMM1                          | 1     | 0.50 | 0.50 | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 4       | 0.50              | scal (6.3%)
MOV (%RSI),%RCX                                    | 1     | 0    | 0    | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 2       | 0.50              | N/A
ADDSS (%RCX,%RAX,4),%XMM1                          | 1     | 0.50 | 0.50 | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 4       | 0.50              | scal (6.3%)
MOVSS %XMM1,(%RDX,%RAX,4)                          | 1     | 0    | 0    | 0    | 0    | 0.50 | 0    | 0    | 0.50 | 0.50 | 0.50 | 3       | 0.50              | scal (6.3%)
ADD $0x1,%RAX                                      | 1     | 0.25 | 0.25 | 0    | 0    | 0    | 0.25 | 0.25 | 0    | 0    | 0    | 1       | 0.25              | N/A
MOV (%RDI),%RCX                                    | 1     | 0    | 0    | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 2       | 0.50              | N/A
MOV 0x8(%RDI),%RDX                                 | 1     | 0    | 0    | 0.50 | 0.50 | 0    | 0    | 0    | 0    | 0    | 0    | 2       | 0.50              | N/A
SUB %RCX,%RDX                                      | 1     | 0.25 | 0.25 | 0    | 0    | 0    | 0.25 | 0.25 | 0    | 0    | 0    | 1       | 0.25              | N/A
SAR $0x2,%RDX                                      | 1     | 0.50 | 0    | 0    | 0    | 0    | 0    | 0.50 | 0    | 0    | 0    | 1       | 0.50              | N/A
CMP %RDX,%RAX                                      | 1     | 0.25 | 0.25 | 0    | 0    | 0    | 0.25 | 0.25 | 0    | 0    | 0    | 1       | 0.25              | N/A
JB 141f <_Z5saxpyfRKSt6vectorIfSaIfEES3_RS1_+0x36> | 1     | 0.50 | 0    | 0    | 0    | 0    | 0    | 0.50 | 0    | 0    | 0    | 0       | 0.50              | N/A



All innermost loops were analyzed.

